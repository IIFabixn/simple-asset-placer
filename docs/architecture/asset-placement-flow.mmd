flowchart TD
    Start([User clicks asset in Asset Browser]) --> BrowserClick[AssetThumbnailItem._on_item_selected]
    
    BrowserClick --> CheckType{Asset Type?}
    
    CheckType -->|3D Model| ModelLib[ModelLibraryBrowser._on_asset_item_selected]
    CheckType -->|MeshLib Item| MeshLib[MeshLibraryBrowser._on_meshlib_item_selected]
    
    ModelLib --> DockSignal1[AssetPlacerDock._on_asset_selected]
    MeshLib --> DockSignal2[AssetPlacerDock._on_meshlib_item_selected]
    
    DockSignal1 --> LoadResource[Load Resource from Path]
    DockSignal2 --> LoadMeshLib[Get Mesh from MeshLibrary]
    
    LoadResource --> MarkUsed[CategoryManager.mark_as_used]
    LoadMeshLib --> MarkUsed
    
    MarkUsed --> EmitSignal[Emit asset_selected / meshlib_item_selected signal]
    
    EmitSignal --> PluginReceive[SimpleAssetPlacer._on_asset_selected]
    
    PluginReceive --> UpdateSettings[SettingsManager.update_dock_settings]
    
    UpdateSettings --> StartPlacement[TransformationCoordinator.start_placement_mode]
    
    StartPlacement --> ExitPrevious[Exit any previous mode]
    
    ExitPrevious --> Transition[ModeStateMachine.transition_to_mode PLACEMENT]
    
    Transition --> CreateSession[TransformSession.begin]
    
    CreateSession --> InitState["Initialize TransformState<br>- position/target_position = Vector3.ZERO<br>- base_height = 0.0, height_offset = 0.0<br>- manual_rotation_offset = Vector3.ZERO<br>- scale_multiplier = 1.0, non_uniform_multiplier = Vector3.ONE<br>- snap settings copied from dock"]
    
    InitState --> EnterHandler[PlacementModeHandler.enter_placement_mode]
    
    EnterHandler --> InitOverlays["OverlayManager.initialize_overlays<br>OverlayManager.set_mode PLACEMENT"]
    
    InitOverlays --> CreatePreview[PreviewManager.start_preview_mesh/asset]
    
    CreatePreview --> InstantiateAsset{Asset Type?}
    
    InstantiateAsset -->|PackedScene| InstScene[Instantiate PackedScene preview]
    InstantiateAsset -->|Mesh| CreateMesh[Create MeshInstance3D preview]

    InstScene --> ApplyTransparency[PreviewManager applies transparency via GeometryInstance3D.transparency]
    CreateMesh --> ApplyTransparency

    ApplyTransparency --> AddToScene[Add preview node to edited scene root]

    AddToScene --> SetInitialTransform["Initialize preview transform from TransformState<br>- global_position = Vector3.ZERO<br>- rotation = Vector3.ZERO<br>- scale = Vector3.ONE"]

    SetInitialTransform --> ConfigureManagers["Configure Managers with dock settings:<br>- PositionManager.configure<br>- RotationManager.configure<br>- ScaleManager.configure<br>- SmoothTransformManager.configure"]
    
    ConfigureManagers --> GrabFocus[Grab 3D viewport focus]
    
    GrabFocus --> PlacementActive[PLACEMENT MODE ACTIVE]
    
    PlacementActive --> FrameLoop{"Every Frame:<br>SimpleAssetPlacer._process"}
    
    FrameLoop --> GetCamera[Get active 3D camera]
    
    GetCamera --> ProcessFrame["TransformationCoordinator.process_frame_input<br>- camera<br>- combined settings<br>- delta"]
    
    ProcessFrame --> Orchestrator[FrameInputOrchestrator.process]
    
    Orchestrator --> UpdateInputState["InputHandler.update_input_state<br>- Mouse position<br>- Key states<br>- Modifiers CTRL/ALT/SHIFT"]
    
    UpdateInputState --> GetInputStates["InputHandler.get_*_input:<br>- position_input<br>- rotation_input<br>- scale_input<br>- control_mode_input<br>- numeric_input"]
    
    GetInputStates --> RouterProcess[TransformActionRouter.process]
    
    RouterProcess --> CheckModal{"Modal Control<br>Active? G/R/L"}
    
    CheckModal -->|Yes - Position G| ModalPosition["Handle Position Modal:<br>- Calculate constrained position<br>- Apply grid snap if enabled<br>- Update TransformState.position<br>- Update preview position"]
    
    CheckModal -->|Yes - Rotation R| ModalRotation["Handle Rotation Modal:<br>- Process mouse delta for rotation<br>- Apply snapping if enabled<br>- Update manual_rotation_offset<br>- Update preview rotation"]
    
    CheckModal -->|Yes - Scale L| ModalScale["Handle Scale Modal:<br>- Process mouse delta for scale<br>- Apply modifiers fine/large<br>- Update scale_multiplier<br>- Update preview scale"]
    
    CheckModal -->|No| NormalInput[Process Normal Input]
    
    ModalPosition --> UpdatePreview1[Update Preview Transform]
    ModalRotation --> UpdatePreview1
    ModalScale --> UpdatePreview1
    
    NormalInput --> MouseMove["Mouse Movement:<br>PositionManager.update_position_from_mouse"]
    
    MouseMove --> Raycast["PlacementStrategyService:<br>- Create ray from camera through mouse<br>- Cast ray against scene geometry<br>- Exclude preview mesh from collision"]
    
    Raycast --> CheckHit{Ray Hit?}
    
    CheckHit -->|Yes| CalculatePos["Calculate position:<br>- Hit point + height offset<br>- Apply grid snap if enabled<br>- Update TransformState.position"]
    
    CheckHit -->|No| KeepCurrent[Keep current position]
    
    CalculatePos --> CheckAlignment{"Align with<br>Normal?"}
    
    CheckAlignment -->|Yes| AlignRotation["RotationManager.align_with_surface_normal<br>- Calculate basis from surface normal<br>- Update surface_alignment_rotation"]
    
    CheckAlignment -->|No| ManualRotation[Use manual rotation only]
    
    AlignRotation --> CombineRotation["Combined Rotation:<br>surface_alignment + manual_offset"]
    ManualRotation --> CombineRotation
    
    KeepCurrent --> CombineRotation
    
    CombineRotation --> CheckKeys{Key Input?}
    
    CheckKeys -->|Q/E Keys| RotateY["RotationManager.rotate_y:<br>- Add/subtract rotation step<br>- Apply modifiers CTRL fine/ALT large<br>- Update manual_rotation_offset.y"]
    
    CheckKeys -->|X/Y/Z Keys| RotateAxis["RotationManager.rotate_axis:<br>- Rotate around specified axis<br>- Apply rotation step with modifiers<br>- Update corresponding offset"]
    
    CheckKeys -->|Mouse Wheel| MouseWheelRot["Fine rotation control:<br>- Small incremental rotation<br>- Apply to current axis"]
    
    CheckKeys -->|W/A/S/D Keys| ManualMove["Camera-relative movement:<br>- Calculate movement vector<br>- Apply to position<br>- Update TransformState.position"]
    
    CheckKeys -->|Page Up/Down| ScaleChange["ScaleManager.adjust_scale:<br>- Multiply scale by increment<br>- Apply modifiers CTRL/ALT<br>- Update scale_multiplier"]
    
    CheckKeys -->|"[ / ]" Keys| CycleAsset["Cycle to next/previous asset:<br>- Get visible items from browser<br>- Find current selection<br>- Select next/previous with wrap-around<br>- Trigger new asset selection"]
    
    RotateY --> SmoothTransform
    RotateAxis --> SmoothTransform
    MouseWheelRot --> SmoothTransform
    ManualMove --> SmoothTransform
    ScaleChange --> SmoothTransform
    CycleAsset --> NewAsset[Load new asset, restart flow]
    
    CheckKeys -->|No Keys| SmoothTransform["SmoothTransformManager.update_smooth_transforms<br>- Interpolate position/rotation/scale<br>- Respect smooth_transforms setting"]
    
    SmoothTransform --> UpdatePreviewMesh["PreviewManager.update_preview_transform<br>- position = TransformState.get_final_position<br>- rotation = surface_alignment + manual offset<br>- scale = non_uniform_multiplier"]
    
    UpdatePreviewMesh --> UpdateOverlay["Update Overlay Display:<br>- Show current position<br>- Show rotation degrees<br>- Show scale values<br>- Show active keybinds"]
    
    UpdateOverlay --> UpdatePreview1
    
    UpdatePreview1 --> CheckPlace{"Left Click<br>or Confirm?"}
    
    CheckPlace -->|Yes| PlaceAsset[PlacementModeHandler.place_at_current_position]
    CheckPlace -->|No| CheckExit{"ESC or<br>Exit Mode?"}
    
    PlaceAsset --> LoadFinalAsset["UtilityManager.place_*_in_scene:<br>- Instantiate PackedScene/Mesh<br>- Ensure unique node name"]

    LoadFinalAsset --> ApplyFinalTransform["SmoothTransformManager.apply_transform_immediately<br>- Position from TransformState.get_final_position<br>- Rotation combines surface/manual offsets<br>- Scale uses scale_multiplier"]

    ApplyFinalTransform --> AddToSceneTree["Node added under edited scene root<br>- Owner assigned for saving"]

    AddToSceneTree --> CreateUndo["UndoRedoHelper.create_placement_undo<br>- Action: Remove node<br>- Undo: Re-add node"]
    
    CreateUndo --> UpdateOverlay2[Update overlay with placement count]
    
    UpdateOverlay2 --> ContinuePlacement["Continue Placement Mode<br>Preview still active"]
    
    ContinuePlacement --> FrameLoop
    
    CheckExit -->|Yes| ExitPlacement[Exit Placement Mode]
    CheckExit -->|No| FrameLoop
    
    ExitPlacement --> CleanupPreview["PreviewManager.cleanup_preview:<br>- Remove preview node from scene<br>- Free node from memory"]
    
    CleanupPreview --> ResetTransforms["Reset transforms if configured:<br>- Reset height if enabled<br>- Reset position if enabled"]
    
    ResetTransforms --> HideOverlay["OverlayManager.hide_transform_overlay<br>Remove grid overlay"]
    
    HideOverlay --> ClearMode["ModeStateMachine.clear_mode<br>TransformSession.reset"]
    
    ClearMode --> End([IDLE - Ready for next asset])
    
    style PlacementActive fill:#4CAF50,stroke:#2E7D32,stroke-width:3px,color:#fff
    style UpdatePreviewMesh fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#fff
    style PlaceAsset fill:#FF9800,stroke:#E65100,stroke-width:3px,color:#fff
    style Raycast fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#fff
    style RouterProcess fill:#F44336,stroke:#C62828,stroke-width:2px,color:#fff
    style FrameLoop fill:#00BCD4,stroke:#006064,stroke-width:2px,color:#fff
